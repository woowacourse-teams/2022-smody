{"version":3,"file":"vendors-node_modules_ol_layer_Graticule_js.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACmE;AACU;AAC7E;AACA,WAAW,4DAA4D;AACvE,WAAW,2CAA2C;AACtD;AACA,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAiD;AAChE;AACA,eAAe,iDAAiD;AAChE;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,4CAA4C;AACvD,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACO;AACP,wBAAwB,6CAAa;AACrC,2BAA2B,mDAAS;AACpC,2BAA2B,mDAAS;AACpC,2BAA2B,mDAAS;AACpC,2BAA2B,mDAAS;AACpC,+BAA+B,mDAAS;AACxC,+BAA+B,mDAAS;AACxC;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAS;AAC3B;AACA,gBAAgB,mDAAS,OAAO,mDAAS;AACzC,KAAK,EAAE,sDAAY;AACnB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,4CAA4C;AACvD,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACO;AACP,6BAA6B,6CAAa;AAC1C;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA,KAAK,EAAE,sDAAY;AACnB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,4CAA4C;AACvD,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACO;AACP,6BAA6B,6CAAa;AAC1C;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA,KAAK,EAAE,sDAAY;AACnB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrJA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD;AACA;AACA;AAC0C;AACK;AACX;AACA;AACmB;AACR;AACV;AACG;AACF;AACF;AACE;AACS;AACkJ;AAC9J;AACA;AACoB;AAC8C;AACrD;AACc;AAC9D;AACA,UAAU;AACV;AACA;AACA;AACA,+BAA+B,wDAAM;AACrC;AACA,CAAC;AACD;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB,cAAc,+BAA+B;AAC7C;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,yBAAyB;AACvC;AACA;AACA;AACA,cAAc,yBAAyB;AACvC;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,0BAA0B,+CAAM;AAChC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB,oEAAwB;AAC9C;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB,oEAAwB;AAC9C;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,2CAA2C,uDAAK;AAChD;AACA;AACA,0BAA0B,sDAAI;AAC9B;AACA;AACA,kCAAkC,sDAAI;AACtC;AACA,yBAAyB;AACzB,oCAAoC,wDAAM;AAC1C;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,aAAa;AACb;AACA;AACA,uBAAuB,8BAA8B;AACrD,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,sBAAsB;AACtB;AACA;AACA,2CAA2C,uDAAK;AAChD;AACA;AACA,0BAA0B,sDAAI;AAC9B;AACA;AACA,kCAAkC,sDAAI;AACtC;AACA,yBAAyB;AACzB,oCAAoC,wDAAM;AAC1C;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,aAAa;AACb;AACA;AACA,uBAAuB,8BAA8B;AACrD,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mCAAmC,uEAAoB;AACvD;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAY;AACxC;AACA;AACA,0BAA0B,sDAAU;AACpC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,+BAA+B,uDAAK;AACpC;AACA,SAAS;AACT;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C,eAAe,QAAQ;AACvB,gBAAgB,sCAAsC;AACtD;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAW;AACvB;AACA;AACA,gBAAgB,gEAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,QAAQ;AACvB,eAAe,yCAAyC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAe;AAC1C;AACA,YAAY,mDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAO;AACnB;AACA;AACA;AACA,qBAAqB,sDAAS;AAC9B;AACA,yDAAyD,oDAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,+BAA+B;AAC9C,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,YAAY,uDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,+BAA+B;AAC9C,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,YAAY,uDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAsC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAQ;AACjC;AACA;AACA,aAAa,2DAAc;AAC3B;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAgB;AAC5C,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,WAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C,eAAe,uCAAuC;AACtD,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAQ;AACjC;AACA;AACA,aAAa,2DAAc;AAC3B,gBAAgB,qDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAK;AACjB,YAAY,gDAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAK;AAC7B,wBAAwB,gDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAK;AACrB,gBAAgB,gDAAK;AACrB,gBAAgB,gDAAK;AACrB,gBAAgB,gDAAK;AACrB;AACA;AACA;AACA,0BAA0B,2DAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAkB;AAClC;AACA;AACA;AACA,gBAAgB,+DAAkB;AAClC;AACA;AACA;AACA,gBAAgB,+DAAkB;AAClC;AACA;AACA;AACA,gBAAgB,+DAAkB;AAClC;AACA;AACA;AACA;AACA,qBAAqB,gDAAK;AAC1B,qBAAqB,gDAAK;AAC1B,qBAAqB,gDAAK;AAC1B,qBAAqB,gDAAK;AAC1B;AACA;AACA;AACA,cAAc,gDAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gDAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gDAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gDAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA,mBAAmB,eAAe;AAClC;AACA,qDAAqD,QAAQ;AAC7D,wBAAwB,gDAAK;AAC7B;AACA,6BAA6B,gDAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,YAAY;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA,8BAA8B,iEAAQ;AACtC;AACA;AACA,6BAA6B,4DAAU,kBAAkB,mEAAiB;AAC1E;AACA;AACA;AACA,0CAA0C,mEAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,+BAA+B;AAC9C,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,YAAY;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA,8BAA8B,iEAAQ;AACtC;AACA;AACA,6BAA6B,4DAAU,kBAAkB,mEAAiB;AAC1E;AACA;AACA,0CAA0C,mEAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,+BAA+B;AAC9C,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAyC;AACxD;AACA;AACA;AACA,iCAAiC,6CAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sDAAY;AAChD,2BAA2B,2DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,sDAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,mDAAW;AACb,iEAAe,SAAS,EAAC;AACzB;;;;;;;;;;;;;;;;;;;;;ACpgCA;AACA;AACA;AACmE;AACrB;AAC+F;AAClF;AACgB;AAC3E;AACA,aAAa,QAAQ;AACrB,cAAc,0BAA0B;AACxC,cAAc,oCAAoC;AAClD,cAAc,4CAA4C;AAC1D,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,8BAA8B,iCAAiC;AAC/D,IAAI,8CAA8C,gBAAgB,OAAO;AACzE;AACA,aAAa,yFAAyF;AACtG;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,0BAA0B;AACxC;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA,SAAS,kBAAkB;AAC3B,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA,WAAW,0BAA0B;AACrC,WAAW,kBAAkB;AAC7B,YAAY,yBAAyB;AACrC;AACA;AACO;AACP;AACA;AACA,2CAA2C,uDAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAc,CAAC,qDAAe;AAClD,eAAe,mEAAuB;AACtC;AACA;AACA;AACA,WAAW,qCAAqC;AAChD,YAAY,yBAAyB;AACrC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAiB;AACrC,2BAA2B,wEAAmB;AAC9C;AACA,yBAAyB,2DAAiB;AAC1C;AACA,wBAAwB,qEAA2B;AACnD;AACA,eAAe,mEAAuB;AACtC;AACA;AACA;AACA,WAAW,qCAAqC;AAChD,WAAW,4BAA4B;AACvC;AACA,YAAY,4BAA4B;AACxC;AACA;AACO;AACP,WAAW,oDAAc;AACzB;AACA","sources":["webpack://@vaadin/bundles/./node_modules/ol/geom/flat/geodesic.js","webpack://@vaadin/bundles/./node_modules/ol/layer/Graticule.js","webpack://@vaadin/bundles/./node_modules/ol/render.js"],"sourcesContent":["/**\n * @module ol/geom/flat/geodesic\n */\nimport { get as getProjection, getTransform } from '../../proj.js';\nimport { squaredSegmentDistance, toDegrees, toRadians } from '../../math.js';\n/**\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\n *     projected coordinates.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nfunction line(interpolate, transform, squaredTolerance) {\n    // FIXME reduce garbage generation\n    // FIXME optimize stack operations\n    /** @type {Array<number>} */\n    var flatCoordinates = [];\n    var geoA = interpolate(0);\n    var geoB = interpolate(1);\n    var a = transform(geoA);\n    var b = transform(geoB);\n    /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n    var geoStack = [geoB, geoA];\n    /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n    var stack = [b, a];\n    /** @type {Array<number>} */\n    var fractionStack = [1, 0];\n    /** @type {!Object<string, boolean>} */\n    var fractions = {};\n    var maxIterations = 1e5;\n    var geoM, m, fracA, fracB, fracM, key;\n    while (--maxIterations > 0 && fractionStack.length > 0) {\n        // Pop the a coordinate off the stack\n        fracA = fractionStack.pop();\n        geoA = geoStack.pop();\n        a = stack.pop();\n        // Add the a coordinate if it has not been added yet\n        key = fracA.toString();\n        if (!(key in fractions)) {\n            flatCoordinates.push(a[0], a[1]);\n            fractions[key] = true;\n        }\n        // Pop the b coordinate off the stack\n        fracB = fractionStack.pop();\n        geoB = geoStack.pop();\n        b = stack.pop();\n        // Find the m point between the a and b coordinates\n        fracM = (fracA + fracB) / 2;\n        geoM = interpolate(fracM);\n        m = transform(geoM);\n        if (squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) <\n            squaredTolerance) {\n            // If the m point is sufficiently close to the straight line, then we\n            // discard it.  Just use the b coordinate and move on to the next line\n            // segment.\n            flatCoordinates.push(b[0], b[1]);\n            key = fracB.toString();\n            fractions[key] = true;\n        }\n        else {\n            // Otherwise, we need to subdivide the current line segment.  Split it\n            // into two and push the two line segments onto the stack.\n            fractionStack.push(fracB, fracM, fracM, fracA);\n            stack.push(b, m, m, a);\n            geoStack.push(geoB, geoM, geoM, geoA);\n        }\n    }\n    return flatCoordinates;\n}\n/**\n * Generate a great-circle arcs between two lat/lon points.\n * @param {number} lon1 Longitude 1 in degrees.\n * @param {number} lat1 Latitude 1 in degrees.\n * @param {number} lon2 Longitude 2 in degrees.\n * @param {number} lat2 Latitude 2 in degrees.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {\n    var geoProjection = getProjection('EPSG:4326');\n    var cosLat1 = Math.cos(toRadians(lat1));\n    var sinLat1 = Math.sin(toRadians(lat1));\n    var cosLat2 = Math.cos(toRadians(lat2));\n    var sinLat2 = Math.sin(toRadians(lat2));\n    var cosDeltaLon = Math.cos(toRadians(lon2 - lon1));\n    var sinDeltaLon = Math.sin(toRadians(lon2 - lon1));\n    var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n    return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n        if (1 <= d) {\n            return [lon2, lat2];\n        }\n        var D = frac * Math.acos(d);\n        var cosD = Math.cos(D);\n        var sinD = Math.sin(D);\n        var y = sinDeltaLon * cosLat2;\n        var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n        var theta = Math.atan2(y, x);\n        var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n        var lon = toRadians(lon1) +\n            Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));\n        return [toDegrees(lon), toDegrees(lat)];\n    }, getTransform(geoProjection, projection), squaredTolerance);\n}\n/**\n * Generate a meridian (line at constant longitude).\n * @param {number} lon Longitude.\n * @param {number} lat1 Latitude 1.\n * @param {number} lat2 Latitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function meridian(lon, lat1, lat2, projection, squaredTolerance) {\n    var epsg4326Projection = getProjection('EPSG:4326');\n    return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n        return [lon, lat1 + (lat2 - lat1) * frac];\n    }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}\n/**\n * Generate a parallel (line at constant latitude).\n * @param {number} lat Latitude.\n * @param {number} lon1 Longitude 1.\n * @param {number} lon2 Longitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function parallel(lat, lon1, lon2, projection, squaredTolerance) {\n    var epsg4326Projection = getProjection('EPSG:4326');\n    return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n        return [lon1 + (lon2 - lon1) * frac, lat];\n    }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}\n//# sourceMappingURL=geodesic.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/layer/Graticule\n */\nimport Collection from '../Collection.js';\nimport EventType from '../render/EventType.js';\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport Point from '../geom/Point.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport VectorLayer from './Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { applyTransform, approximatelyEquals, containsCoordinate, containsExtent, equals, getCenter, getIntersection, getWidth, intersects, isEmpty, wrapX as wrapExtentX, } from '../extent.js';\nimport { assign } from '../obj.js';\nimport { clamp } from '../math.js';\nimport { degreesToStringHDMS } from '../coordinate.js';\nimport { equivalent as equivalentProjection, get as getProjection, getTransform, } from '../proj.js';\nimport { getVectorContext } from '../render.js';\nimport { meridian, parallel } from '../geom/flat/geodesic.js';\n/**\n * @type {Stroke}\n * @private\n * @const\n */\nvar DEFAULT_STROKE_STYLE = new Stroke({\n    color: 'rgba(0,0,0,0.2)',\n});\n/**\n * @type {Array<number>}\n * @private\n */\nvar INTERVALS = [\n    90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001,\n];\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom Geometry.\n * @property {string} text Text.\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle] The\n * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:\n * ```js\n * new Stroke({\n *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black\n * });\n * ```\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\n * @api\n */\nvar Graticule = /** @class */ (function (_super) {\n    __extends(Graticule, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function Graticule(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        var baseOptions = assign({\n            updateWhileAnimating: true,\n            updateWhileInteracting: true,\n            renderBuffer: 0,\n        }, options);\n        delete baseOptions.maxLines;\n        delete baseOptions.strokeStyle;\n        delete baseOptions.targetSize;\n        delete baseOptions.showLabels;\n        delete baseOptions.lonLabelFormatter;\n        delete baseOptions.latLabelFormatter;\n        delete baseOptions.lonLabelPosition;\n        delete baseOptions.latLabelPosition;\n        delete baseOptions.lonLabelStyle;\n        delete baseOptions.latLabelStyle;\n        delete baseOptions.intervals;\n        _this = _super.call(this, baseOptions) || this;\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         */\n        _this.projection_ = null;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxLat_ = Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxLon_ = Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.minLat_ = -Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.minLon_ = -Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxX_ = Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxY_ = Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.minX_ = -Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.minY_ = -Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.targetSize_ =\n            options.targetSize !== undefined ? options.targetSize : 100;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n        /**\n         * @type {Array<LineString>}\n         * @private\n         */\n        _this.meridians_ = [];\n        /**\n         * @type {Array<LineString>}\n         * @private\n         */\n        _this.parallels_ = [];\n        /**\n         * @type {Stroke}\n         * @private\n         */\n        _this.strokeStyle_ =\n            options.strokeStyle !== undefined\n                ? options.strokeStyle\n                : DEFAULT_STROKE_STYLE;\n        /**\n         * @type {import(\"../proj.js\").TransformFunction|undefined}\n         * @private\n         */\n        _this.fromLonLatTransform_ = undefined;\n        /**\n         * @type {import(\"../proj.js\").TransformFunction|undefined}\n         * @private\n         */\n        _this.toLonLatTransform_ = undefined;\n        /**\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.projectionCenterLonLat_ = null;\n        /**\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.bottomLeft_ = null;\n        /**\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.bottomRight_ = null;\n        /**\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.topLeft_ = null;\n        /**\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.topRight_ = null;\n        /**\n         * @type {Array<GraticuleLabelDataType>}\n         * @private\n         */\n        _this.meridiansLabels_ = null;\n        /**\n         * @type {Array<GraticuleLabelDataType>}\n         * @private\n         */\n        _this.parallelsLabels_ = null;\n        if (options.showLabels) {\n            /**\n             * @type {null|function(number):string}\n             * @private\n             */\n            _this.lonLabelFormatter_ =\n                options.lonLabelFormatter == undefined\n                    ? degreesToStringHDMS.bind(_this, 'EW')\n                    : options.lonLabelFormatter;\n            /**\n             * @type {function(number):string}\n             * @private\n             */\n            _this.latLabelFormatter_ =\n                options.latLabelFormatter == undefined\n                    ? degreesToStringHDMS.bind(_this, 'NS')\n                    : options.latLabelFormatter;\n            /**\n             * Longitude label position in fractions (0..1) of view extent. 0 means\n             * bottom, 1 means top.\n             * @type {number}\n             * @private\n             */\n            _this.lonLabelPosition_ =\n                options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n            /**\n             * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n             * means right.\n             * @type {number}\n             * @private\n             */\n            _this.latLabelPosition_ =\n                options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n            /**\n             * @type {Style}\n             * @private\n             */\n            _this.lonLabelStyleBase_ = new Style({\n                text: options.lonLabelStyle !== undefined\n                    ? options.lonLabelStyle.clone()\n                    : new Text({\n                        font: '12px Calibri,sans-serif',\n                        textBaseline: 'bottom',\n                        fill: new Fill({\n                            color: 'rgba(0,0,0,1)',\n                        }),\n                        stroke: new Stroke({\n                            color: 'rgba(255,255,255,1)',\n                            width: 3,\n                        }),\n                    }),\n            });\n            /**\n             * @private\n             * @param {import(\"../Feature\").default} feature Feature\n             * @return {Style} style\n             */\n            _this.lonLabelStyle_ = function (feature) {\n                var label = feature.get('graticule_label');\n                this.lonLabelStyleBase_.getText().setText(label);\n                return this.lonLabelStyleBase_;\n            }.bind(_this);\n            /**\n             * @type {Style}\n             * @private\n             */\n            _this.latLabelStyleBase_ = new Style({\n                text: options.latLabelStyle !== undefined\n                    ? options.latLabelStyle.clone()\n                    : new Text({\n                        font: '12px Calibri,sans-serif',\n                        textAlign: 'right',\n                        fill: new Fill({\n                            color: 'rgba(0,0,0,1)',\n                        }),\n                        stroke: new Stroke({\n                            color: 'rgba(255,255,255,1)',\n                            width: 3,\n                        }),\n                    }),\n            });\n            /**\n             * @private\n             * @param {import(\"../Feature\").default} feature Feature\n             * @return {Style} style\n             */\n            _this.latLabelStyle_ = function (feature) {\n                var label = feature.get('graticule_label');\n                this.latLabelStyleBase_.getText().setText(label);\n                return this.latLabelStyleBase_;\n            }.bind(_this);\n            _this.meridiansLabels_ = [];\n            _this.parallelsLabels_ = [];\n            _this.addEventListener(EventType.POSTRENDER, _this.drawLabels_.bind(_this));\n        }\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.intervals_ =\n            options.intervals !== undefined ? options.intervals : INTERVALS;\n        // use a source with a custom loader for lines & text\n        _this.setSource(new VectorSource({\n            loader: _this.loaderFunction.bind(_this),\n            strategy: _this.strategyFunction.bind(_this),\n            features: new Collection(),\n            overlaps: false,\n            useSpatialIndex: false,\n            wrapX: options.wrapX,\n        }));\n        /**\n         * feature pool to use when updating graticule\n         * @type {Array<Feature>}\n         * @private\n         */\n        _this.featurePool_ = [];\n        /**\n         * @type {Style}\n         * @private\n         */\n        _this.lineStyle_ = new Style({\n            stroke: _this.strokeStyle_,\n        });\n        /**\n         * @type {?import(\"../extent.js\").Extent}\n         * @private\n         */\n        _this.loadedExtent_ = null;\n        /**\n         * @type {?import(\"../extent.js\").Extent}\n         * @private\n         */\n        _this.renderedExtent_ = null;\n        /**\n         * @type {?number}\n         * @private\n         */\n        _this.renderedResolution_ = null;\n        _this.setRenderOrder(null);\n        return _this;\n    }\n    /**\n     * Strategy function for loading features based on the view's extent and\n     * resolution.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @return {Array<import(\"../extent.js\").Extent>} Extents.\n     */\n    Graticule.prototype.strategyFunction = function (extent, resolution) {\n        // extents may be passed in different worlds, to avoid endless loop we use only one\n        var realWorldExtent = extent.slice();\n        if (this.projection_ && this.getSource().getWrapX()) {\n            wrapExtentX(realWorldExtent, this.projection_);\n        }\n        if (this.loadedExtent_) {\n            if (approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)) {\n                // make sure result is exactly equal to previous extent\n                realWorldExtent = this.loadedExtent_.slice();\n            }\n            else {\n                // we should not keep track of loaded extents\n                this.getSource().removeLoadedExtent(this.loadedExtent_);\n            }\n        }\n        return [realWorldExtent];\n    };\n    /**\n     * Update geometries in the source based on current view\n     * @param {import(\"../extent\").Extent} extent Extent\n     * @param {number} resolution Resolution\n     * @param {import(\"../proj/Projection.js\").default} projection Projection\n     */\n    Graticule.prototype.loaderFunction = function (extent, resolution, projection) {\n        this.loadedExtent_ = extent;\n        var source = this.getSource();\n        // only consider the intersection between our own extent & the requested one\n        var layerExtent = this.getExtent() || [\n            -Infinity,\n            -Infinity,\n            Infinity,\n            Infinity,\n        ];\n        var renderExtent = getIntersection(layerExtent, extent);\n        if (this.renderedExtent_ &&\n            equals(this.renderedExtent_, renderExtent) &&\n            this.renderedResolution_ === resolution) {\n            return;\n        }\n        this.renderedExtent_ = renderExtent;\n        this.renderedResolution_ = resolution;\n        // bail out if nothing to render\n        if (isEmpty(renderExtent)) {\n            return;\n        }\n        // update projection info\n        var center = getCenter(renderExtent);\n        var squaredTolerance = (resolution * resolution) / 4;\n        var updateProjectionInfo = !this.projection_ || !equivalentProjection(this.projection_, projection);\n        if (updateProjectionInfo) {\n            this.updateProjectionInfo_(projection);\n        }\n        this.createGraticule_(renderExtent, center, resolution, squaredTolerance);\n        // first make sure we have enough features in the pool\n        var featureCount = this.meridians_.length + this.parallels_.length;\n        if (this.meridiansLabels_) {\n            featureCount += this.meridians_.length;\n        }\n        if (this.parallelsLabels_) {\n            featureCount += this.parallels_.length;\n        }\n        var feature;\n        while (featureCount > this.featurePool_.length) {\n            feature = new Feature();\n            this.featurePool_.push(feature);\n        }\n        var featuresColl = source.getFeaturesCollection();\n        featuresColl.clear();\n        var poolIndex = 0;\n        // add features for the lines & labels\n        var i, l;\n        for (i = 0, l = this.meridians_.length; i < l; ++i) {\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(this.meridians_[i]);\n            feature.setStyle(this.lineStyle_);\n            featuresColl.push(feature);\n        }\n        for (i = 0, l = this.parallels_.length; i < l; ++i) {\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(this.parallels_[i]);\n            feature.setStyle(this.lineStyle_);\n            featuresColl.push(feature);\n        }\n    };\n    /**\n     * @param {number} lon Longitude.\n     * @param {number} minLat Minimal latitude.\n     * @param {number} maxLat Maximal latitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {number} Index.\n     * @private\n     */\n    Graticule.prototype.addMeridian_ = function (lon, minLat, maxLat, squaredTolerance, extent, index) {\n        var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);\n        if (intersects(lineString.getExtent(), extent)) {\n            if (this.meridiansLabels_) {\n                var text = this.lonLabelFormatter_(lon);\n                if (index in this.meridiansLabels_) {\n                    this.meridiansLabels_[index].text = text;\n                }\n                else {\n                    this.meridiansLabels_[index] = {\n                        geom: new Point([]),\n                        text: text,\n                    };\n                }\n            }\n            this.meridians_[index++] = lineString;\n        }\n        return index;\n    };\n    /**\n     * @param {number} lat Latitude.\n     * @param {number} minLon Minimal longitude.\n     * @param {number} maxLon Maximal longitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {number} Index.\n     * @private\n     */\n    Graticule.prototype.addParallel_ = function (lat, minLon, maxLon, squaredTolerance, extent, index) {\n        var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);\n        if (intersects(lineString.getExtent(), extent)) {\n            if (this.parallelsLabels_) {\n                var text = this.latLabelFormatter_(lat);\n                if (index in this.parallelsLabels_) {\n                    this.parallelsLabels_[index].text = text;\n                }\n                else {\n                    this.parallelsLabels_[index] = {\n                        geom: new Point([]),\n                        text: text,\n                    };\n                }\n            }\n            this.parallels_[index++] = lineString;\n        }\n        return index;\n    };\n    /**\n     * @param {import(\"../render/Event.js\").default} event Render event.\n     * @private\n     */\n    Graticule.prototype.drawLabels_ = function (event) {\n        var rotation = event.frameState.viewState.rotation;\n        var resolution = event.frameState.viewState.resolution;\n        var size = event.frameState.size;\n        var extent = event.frameState.extent;\n        var rotationCenter = getCenter(extent);\n        var rotationExtent = extent;\n        if (rotation) {\n            var unrotatedWidth = size[0] * resolution;\n            var unrotatedHeight = size[1] * resolution;\n            rotationExtent = [\n                rotationCenter[0] - unrotatedWidth / 2,\n                rotationCenter[1] - unrotatedHeight / 2,\n                rotationCenter[0] + unrotatedWidth / 2,\n                rotationCenter[1] + unrotatedHeight / 2,\n            ];\n        }\n        var startWorld = 0;\n        var endWorld = 0;\n        var labelsAtStart = this.latLabelPosition_ < 0.5;\n        var projectionExtent = this.projection_.getExtent();\n        var worldWidth = getWidth(projectionExtent);\n        if (this.getSource().getWrapX() &&\n            this.projection_.canWrapX() &&\n            !containsExtent(projectionExtent, extent)) {\n            startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n            endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n            var inverted = Math.abs(rotation) > Math.PI / 2;\n            labelsAtStart = labelsAtStart !== inverted;\n        }\n        var vectorContext = getVectorContext(event);\n        for (var world = startWorld; world <= endWorld; ++world) {\n            var poolIndex = this.meridians_.length + this.parallels_.length;\n            var feature = void 0, index = void 0, l = void 0, textPoint = void 0;\n            if (this.meridiansLabels_) {\n                for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n                    var lineString = this.meridians_[index];\n                    if (!rotation && world === 0) {\n                        textPoint = this.getMeridianPoint_(lineString, extent, index);\n                    }\n                    else {\n                        var clone = lineString.clone();\n                        clone.translate(world * worldWidth, 0);\n                        clone.rotate(-rotation, rotationCenter);\n                        textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n                        textPoint.rotate(rotation, rotationCenter);\n                    }\n                    feature = this.featurePool_[poolIndex++];\n                    feature.setGeometry(textPoint);\n                    feature.set('graticule_label', this.meridiansLabels_[index].text);\n                    vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n                }\n            }\n            if (this.parallelsLabels_) {\n                if ((world === startWorld && labelsAtStart) ||\n                    (world === endWorld && !labelsAtStart)) {\n                    for (index = 0, l = this.parallels_.length; index < l; ++index) {\n                        var lineString = this.parallels_[index];\n                        if (!rotation && world === 0) {\n                            textPoint = this.getParallelPoint_(lineString, extent, index);\n                        }\n                        else {\n                            var clone = lineString.clone();\n                            clone.translate(world * worldWidth, 0);\n                            clone.rotate(-rotation, rotationCenter);\n                            textPoint = this.getParallelPoint_(clone, rotationExtent, index);\n                            textPoint.rotate(rotation, rotationCenter);\n                        }\n                        feature = this.featurePool_[poolIndex++];\n                        feature.setGeometry(textPoint);\n                        feature.set('graticule_label', this.parallelsLabels_[index].text);\n                        vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {import(\"../coordinate.js\").Coordinate} center Center.\n     * @param {number} resolution Resolution.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @private\n     */\n    Graticule.prototype.createGraticule_ = function (extent, center, resolution, squaredTolerance) {\n        var interval = this.getInterval_(resolution);\n        if (interval == -1) {\n            this.meridians_.length = 0;\n            this.parallels_.length = 0;\n            if (this.meridiansLabels_) {\n                this.meridiansLabels_.length = 0;\n            }\n            if (this.parallelsLabels_) {\n                this.parallelsLabels_.length = 0;\n            }\n            return;\n        }\n        var wrapX = false;\n        var projectionExtent = this.projection_.getExtent();\n        var worldWidth = getWidth(projectionExtent);\n        if (this.getSource().getWrapX() &&\n            this.projection_.canWrapX() &&\n            !containsExtent(projectionExtent, extent)) {\n            if (getWidth(extent) >= worldWidth) {\n                extent[0] = projectionExtent[0];\n                extent[2] = projectionExtent[2];\n            }\n            else {\n                wrapX = true;\n            }\n        }\n        // Constrain the center to fit into the extent available to the graticule\n        var validCenterP = [\n            clamp(center[0], this.minX_, this.maxX_),\n            clamp(center[1], this.minY_, this.maxY_),\n        ];\n        // Transform the center to lon lat\n        // Some projections may have a void area at the poles\n        // so replace any NaN latitudes with the min or max value closest to a pole\n        var centerLonLat = this.toLonLatTransform_(validCenterP);\n        if (isNaN(centerLonLat[1])) {\n            centerLonLat[1] =\n                Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n                    ? this.maxLat_\n                    : this.minLat_;\n        }\n        var centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\n        var centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\n        var maxLines = this.maxLines_;\n        var cnt, idx, lat, lon;\n        // Limit the extent to fit into the extent available to the graticule\n        var validExtentP = extent;\n        if (!wrapX) {\n            validExtentP = [\n                clamp(extent[0], this.minX_, this.maxX_),\n                clamp(extent[1], this.minY_, this.maxY_),\n                clamp(extent[2], this.minX_, this.maxX_),\n                clamp(extent[3], this.minY_, this.maxY_),\n            ];\n        }\n        // Transform the extent to get the lon lat ranges for the edges of the extent\n        var validExtent = applyTransform(validExtentP, this.toLonLatTransform_, undefined, 8);\n        var maxLat = validExtent[3];\n        var maxLon = validExtent[2];\n        var minLat = validExtent[1];\n        var minLon = validExtent[0];\n        if (!wrapX) {\n            // Check if extremities of the world extent lie inside the extent\n            // (for example the pole in a polar projection)\n            // and extend the extent as appropriate\n            if (containsCoordinate(validExtentP, this.bottomLeft_)) {\n                minLon = this.minLon_;\n                minLat = this.minLat_;\n            }\n            if (containsCoordinate(validExtentP, this.bottomRight_)) {\n                maxLon = this.maxLon_;\n                minLat = this.minLat_;\n            }\n            if (containsCoordinate(validExtentP, this.topLeft_)) {\n                minLon = this.minLon_;\n                maxLat = this.maxLat_;\n            }\n            if (containsCoordinate(validExtentP, this.topRight_)) {\n                maxLon = this.maxLon_;\n                maxLat = this.maxLat_;\n            }\n            // The transformed center may also extend the lon lat ranges used for rendering\n            maxLat = clamp(maxLat, centerLat, this.maxLat_);\n            maxLon = clamp(maxLon, centerLon, this.maxLon_);\n            minLat = clamp(minLat, this.minLat_, centerLat);\n            minLon = clamp(minLon, this.minLon_, centerLon);\n        }\n        // Create meridians\n        centerLon = Math.floor(centerLon / interval) * interval;\n        lon = clamp(centerLon, this.minLon_, this.maxLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n        cnt = 0;\n        if (wrapX) {\n            while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n                idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n            }\n        }\n        else {\n            while (lon != this.minLon_ && cnt++ < maxLines) {\n                lon = Math.max(lon - interval, this.minLon_);\n                idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n            }\n        }\n        lon = clamp(centerLon, this.minLon_, this.maxLon_);\n        cnt = 0;\n        if (wrapX) {\n            while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n                idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n            }\n        }\n        else {\n            while (lon != this.maxLon_ && cnt++ < maxLines) {\n                lon = Math.min(lon + interval, this.maxLon_);\n                idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n            }\n        }\n        this.meridians_.length = idx;\n        if (this.meridiansLabels_) {\n            this.meridiansLabels_.length = idx;\n        }\n        // Create parallels\n        centerLat = Math.floor(centerLat / interval) * interval;\n        lat = clamp(centerLat, this.minLat_, this.maxLat_);\n        idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n        cnt = 0;\n        while (lat != this.minLat_ && cnt++ < maxLines) {\n            lat = Math.max(lat - interval, this.minLat_);\n            idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n        }\n        lat = clamp(centerLat, this.minLat_, this.maxLat_);\n        cnt = 0;\n        while (lat != this.maxLat_ && cnt++ < maxLines) {\n            lat = Math.min(lat + interval, this.maxLat_);\n            idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n        }\n        this.parallels_.length = idx;\n        if (this.parallelsLabels_) {\n            this.parallelsLabels_.length = idx;\n        }\n    };\n    /**\n     * @param {number} resolution Resolution.\n     * @return {number} The interval in degrees.\n     * @private\n     */\n    Graticule.prototype.getInterval_ = function (resolution) {\n        var centerLon = this.projectionCenterLonLat_[0];\n        var centerLat = this.projectionCenterLonLat_[1];\n        var interval = -1;\n        var target = Math.pow(this.targetSize_ * resolution, 2);\n        /** @type {Array<number>} **/\n        var p1 = [];\n        /** @type {Array<number>} **/\n        var p2 = [];\n        for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {\n            var delta = clamp(this.intervals_[i] / 2, 0, 90);\n            // Don't attempt to transform latitudes beyond the poles!\n            var clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\n            p1[0] = centerLon - delta;\n            p1[1] = clampedLat - delta;\n            p2[0] = centerLon + delta;\n            p2[1] = clampedLat + delta;\n            this.fromLonLatTransform_(p1, p1);\n            this.fromLonLatTransform_(p2, p2);\n            var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n            if (dist <= target) {\n                break;\n            }\n            interval = this.intervals_[i];\n        }\n        return interval;\n    };\n    /**\n     * @param {number} lon Longitude.\n     * @param {number} minLat Minimal latitude.\n     * @param {number} maxLat Maximal latitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LineString} The meridian line string.\n     * @param {number} index Index.\n     * @private\n     */\n    Graticule.prototype.getMeridian_ = function (lon, minLat, maxLat, squaredTolerance, index) {\n        var flatCoordinates = meridian(lon, minLat, maxLat, this.projection_, squaredTolerance);\n        var lineString = this.meridians_[index];\n        if (!lineString) {\n            lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n            this.meridians_[index] = lineString;\n        }\n        else {\n            lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n            lineString.changed();\n        }\n        return lineString;\n    };\n    /**\n     * @param {LineString} lineString Meridian\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {Point} Meridian point.\n     * @private\n     */\n    Graticule.prototype.getMeridianPoint_ = function (lineString, extent, index) {\n        var flatCoordinates = lineString.getFlatCoordinates();\n        var bottom = 1;\n        var top = flatCoordinates.length - 1;\n        if (flatCoordinates[bottom] > flatCoordinates[top]) {\n            bottom = top;\n            top = 1;\n        }\n        var clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n        var clampedTop = Math.min(extent[3], flatCoordinates[top]);\n        var lat = clamp(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);\n        var coordinate0 = flatCoordinates[bottom - 1] +\n            ((flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) *\n                (lat - flatCoordinates[bottom])) /\n                (flatCoordinates[top] - flatCoordinates[bottom]);\n        var coordinate = [coordinate0, lat];\n        var point = this.meridiansLabels_[index].geom;\n        point.setCoordinates(coordinate);\n        return point;\n    };\n    /**\n     * Get the list of meridians.  Meridians are lines of equal longitude.\n     * @return {Array<LineString>} The meridians.\n     * @api\n     */\n    Graticule.prototype.getMeridians = function () {\n        return this.meridians_;\n    };\n    /**\n     * @param {number} lat Latitude.\n     * @param {number} minLon Minimal longitude.\n     * @param {number} maxLon Maximal longitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LineString} The parallel line string.\n     * @param {number} index Index.\n     * @private\n     */\n    Graticule.prototype.getParallel_ = function (lat, minLon, maxLon, squaredTolerance, index) {\n        var flatCoordinates = parallel(lat, minLon, maxLon, this.projection_, squaredTolerance);\n        var lineString = this.parallels_[index];\n        if (!lineString) {\n            lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n        }\n        else {\n            lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n            lineString.changed();\n        }\n        return lineString;\n    };\n    /**\n     * @param {LineString} lineString Parallels.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {Point} Parallel point.\n     * @private\n     */\n    Graticule.prototype.getParallelPoint_ = function (lineString, extent, index) {\n        var flatCoordinates = lineString.getFlatCoordinates();\n        var left = 0;\n        var right = flatCoordinates.length - 2;\n        if (flatCoordinates[left] > flatCoordinates[right]) {\n            left = right;\n            right = 0;\n        }\n        var clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n        var clampedRight = Math.min(extent[2], flatCoordinates[right]);\n        var lon = clamp(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);\n        var coordinate1 = flatCoordinates[left + 1] +\n            ((flatCoordinates[right + 1] - flatCoordinates[left + 1]) *\n                (lon - flatCoordinates[left])) /\n                (flatCoordinates[right] - flatCoordinates[left]);\n        var coordinate = [lon, coordinate1];\n        var point = this.parallelsLabels_[index].geom;\n        point.setCoordinates(coordinate);\n        return point;\n    };\n    /**\n     * Get the list of parallels.  Parallels are lines of equal latitude.\n     * @return {Array<LineString>} The parallels.\n     * @api\n     */\n    Graticule.prototype.getParallels = function () {\n        return this.parallels_;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @private\n     */\n    Graticule.prototype.updateProjectionInfo_ = function (projection) {\n        var epsg4326Projection = getProjection('EPSG:4326');\n        var worldExtent = projection.getWorldExtent();\n        this.maxLat_ = worldExtent[3];\n        this.maxLon_ = worldExtent[2];\n        this.minLat_ = worldExtent[1];\n        this.minLon_ = worldExtent[0];\n        // If the world extent crosses the dateline define a custom transform to\n        // return longitudes which wrap the dateline\n        var toLonLatTransform = getTransform(projection, epsg4326Projection);\n        if (this.minLon_ < this.maxLon_) {\n            this.toLonLatTransform_ = toLonLatTransform;\n        }\n        else {\n            var split_1 = this.minLon_ + this.maxLon_ / 2;\n            this.maxLon_ += 360;\n            this.toLonLatTransform_ = function (coordinates, opt_output, opt_dimension) {\n                var dimension = opt_dimension || 2;\n                var lonLatCoordinates = toLonLatTransform(coordinates, opt_output, dimension);\n                for (var i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n                    if (lonLatCoordinates[i] < split_1) {\n                        lonLatCoordinates[i] += 360;\n                    }\n                }\n                return lonLatCoordinates;\n            };\n        }\n        // Transform the extent to get the limits of the view projection extent\n        // which should be available to the graticule\n        this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n        var worldExtentP = applyTransform([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, undefined, 8);\n        this.minX_ = worldExtentP[0];\n        this.maxX_ = worldExtentP[2];\n        this.minY_ = worldExtentP[1];\n        this.maxY_ = worldExtentP[3];\n        // Determine the view projection coordinates of the extremities of the world extent\n        // as these may lie inside a view extent (for example the pole in a polar projection)\n        this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n        this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n        this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n        this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);\n        // Transform the projection center to lon lat\n        // Some projections may have a void area at the poles\n        // so replace any NaN latitudes with the min or max value closest to a pole\n        this.projectionCenterLonLat_ = this.toLonLatTransform_(getCenter(projection.getExtent()));\n        if (isNaN(this.projectionCenterLonLat_[1])) {\n            this.projectionCenterLonLat_[1] =\n                Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n                    ? this.maxLat_\n                    : this.minLat_;\n        }\n        this.projection_ = projection;\n    };\n    return Graticule;\n}(VectorLayer));\nexport default Graticule;\n//# sourceMappingURL=Graticule.js.map","/**\n * @module ol/render\n */\nimport CanvasImmediateRenderer from './render/canvas/Immediate.js';\nimport { DEVICE_PIXEL_RATIO } from './has.js';\nimport { apply as applyTransform, create as createTransform, multiply as multiplyTransform, scale as scaleTransform, } from './transform.js';\nimport { getSquaredTolerance } from './renderer/vector.js';\nimport { getTransformFromProjections, getUserProjection } from './proj.js';\n/**\n * @typedef {Object} State\n * @property {CanvasRenderingContext2D} context Canvas context that the layer is being rendered to.\n * @property {import(\"./Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"./geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} pixelRatio Pixel ratio used by the layer renderer.\n * @property {number} resolution Resolution that the render batch was created and optimized for.\n * This is not the view's resolution that is being rendered.\n * @property {number} rotation Rotation of the rendered layer in radians.\n */\n/**\n * A function to be used when sorting features before rendering.\n * It takes two instances of {@link module:ol/Feature~Feature} or\n * {@link module:ol/render/Feature~RenderFeature} and returns a `{number}`.\n *\n * @typedef {function(import(\"./Feature.js\").FeatureLike, import(\"./Feature.js\").FeatureLike):number} OrderFunction\n */\n/**\n * @typedef {Object} ToContextOptions\n * @property {import(\"./size.js\").Size} [size] Desired size of the canvas in css\n * pixels. When provided, both canvas and css size will be set according to the\n * `pixelRatio`. If not provided, the current canvas and css sizes will not be\n * altered.\n * @property {number} [pixelRatio=window.devicePixelRatio] Pixel ratio (canvas\n * pixel to css pixel ratio) for the canvas.\n */\n/**\n * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries\n * to the context's canvas.\n *\n * The units for geometry coordinates are css pixels relative to the top left\n * corner of the canvas element.\n * ```js\n * import {toContext} from 'ol/render';\n * import Fill from 'ol/style/Fill';\n * import Polygon from 'ol/geom/Polygon';\n *\n * var canvas = document.createElement('canvas');\n * var render = toContext(canvas.getContext('2d'),\n *     { size: [100, 100] });\n * render.setFillStrokeStyle(new Fill({ color: blue }));\n * render.drawPolygon(\n *     new Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]]));\n * ```\n *\n * @param {CanvasRenderingContext2D} context Canvas context.\n * @param {ToContextOptions} [opt_options] Options.\n * @return {CanvasImmediateRenderer} Canvas Immediate.\n * @api\n */\nexport function toContext(context, opt_options) {\n    var canvas = context.canvas;\n    var options = opt_options ? opt_options : {};\n    var pixelRatio = options.pixelRatio || DEVICE_PIXEL_RATIO;\n    var size = options.size;\n    if (size) {\n        canvas.width = size[0] * pixelRatio;\n        canvas.height = size[1] * pixelRatio;\n        canvas.style.width = size[0] + 'px';\n        canvas.style.height = size[1] + 'px';\n    }\n    var extent = [0, 0, canvas.width, canvas.height];\n    var transform = scaleTransform(createTransform(), pixelRatio, pixelRatio);\n    return new CanvasImmediateRenderer(context, pixelRatio, extent, transform, 0);\n}\n/**\n * Gets a vector context for drawing to the event's canvas.\n * @param {import(\"./render/Event.js\").default} event Render event.\n * @return {CanvasImmediateRenderer} Vector context.\n * @api\n */\nexport function getVectorContext(event) {\n    if (!(event.context instanceof CanvasRenderingContext2D)) {\n        throw new Error('Only works for render events from Canvas 2D layers');\n    }\n    // canvas may be at a different pixel ratio than frameState.pixelRatio\n    var canvasPixelRatio = event.inversePixelTransform[0];\n    var frameState = event.frameState;\n    var transform = multiplyTransform(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);\n    var squaredTolerance = getSquaredTolerance(frameState.viewState.resolution, canvasPixelRatio);\n    var userTransform;\n    var userProjection = getUserProjection();\n    if (userProjection) {\n        userTransform = getTransformFromProjections(userProjection, frameState.viewState.projection);\n    }\n    return new CanvasImmediateRenderer(event.context, canvasPixelRatio, frameState.extent, transform, frameState.viewState.rotation, squaredTolerance, userTransform);\n}\n/**\n * Gets the pixel of the event's canvas context from the map viewport's CSS pixel.\n * @param {import(\"./render/Event.js\").default} event Render event.\n * @param {import(\"./pixel.js\").Pixel} pixel CSS pixel relative to the top-left\n * corner of the map viewport.\n * @return {import(\"./pixel.js\").Pixel} Pixel on the event's canvas context.\n * @api\n */\nexport function getRenderPixel(event, pixel) {\n    return applyTransform(event.inversePixelTransform, pixel.slice(0));\n}\n//# sourceMappingURL=render.js.map"],"names":[],"sourceRoot":""}